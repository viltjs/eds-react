var mn = (C, b) => () => (b || C((b = { exports: {} }).exports, b), b.exports);
var fn = mn((Tt, xe) => {
  /*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */
  (function(C, b) {
    typeof Tt == "object" && typeof xe < "u" ? xe.exports = b() : typeof define == "function" && define.amd ? define(b) : (C = typeof globalThis < "u" ? globalThis : C || self).DOMPurify = b();
  })(void 0, function() {
    const { entries: C, setPrototypeOf: b, isFrozen: yt, getPrototypeOf: Et, getOwnPropertyDescriptor: At } = Object;
    let { freeze: h, seal: N, create: Me } = Object, { apply: ce, construct: ue } = typeof Reflect < "u" && Reflect;
    h || (h = function(s) {
      return s;
    }), N || (N = function(s) {
      return s;
    }), ce || (ce = function(s, l, o) {
      return s.apply(l, o);
    }), ue || (ue = function(s, l) {
      return new s(...l);
    });
    const Z = y(Array.prototype.forEach), _t = y(Array.prototype.lastIndexOf), ke = y(Array.prototype.pop), F = y(Array.prototype.push), St = y(Array.prototype.splice), J = y(String.prototype.toLowerCase), me = y(String.prototype.toString), Ie = y(String.prototype.match), B = y(String.prototype.replace), Nt = y(String.prototype.indexOf), bt = y(String.prototype.trim), R = y(Object.prototype.hasOwnProperty), T = y(RegExp.prototype.test), W = (Ue = TypeError, function() {
      for (var s = arguments.length, l = new Array(s), o = 0; o < s; o++) l[o] = arguments[o];
      return ue(Ue, l);
    });
    var Ue;
    function y(s) {
      return function(l) {
        for (var o = arguments.length, u = new Array(o > 1 ? o - 1 : 0), S = 1; S < o; S++) u[S - 1] = arguments[S];
        return ce(s, l, u);
      };
    }
    function r(s, l) {
      let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : J;
      b && b(s, null);
      let u = l.length;
      for (; u--; ) {
        let S = l[u];
        if (typeof S == "string") {
          const Y = o(S);
          Y !== S && (yt(l) || (l[u] = Y), S = Y);
        }
        s[S] = !0;
      }
      return s;
    }
    function Rt(s) {
      for (let l = 0; l < s.length; l++)
        R(s, l) || (s[l] = null);
      return s;
    }
    function x(s) {
      const l = Me(null);
      for (const [o, u] of C(s))
        R(s, o) && (Array.isArray(u) ? l[o] = Rt(u) : u && typeof u == "object" && u.constructor === Object ? l[o] = x(u) : l[o] = u);
      return l;
    }
    function G(s, l) {
      for (; s !== null; ) {
        const o = At(s, l);
        if (o) {
          if (o.get) return y(o.get);
          if (typeof o.value == "function") return y(o.value);
        }
        s = Et(s);
      }
      return function() {
        return null;
      };
    }
    const ze = h(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), fe = h(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), pe = h(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), wt = h(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), de = h(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Ot = h(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Pe = h(["#text"]), He = h(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), ge = h(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Fe = h(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Q = h(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), Dt = N(/\{\{[\w\W]*|[\w\W]*\}\}/gm), vt = N(/<%[\w\W]*|[\w\W]*%>/gm), Lt = N(/\$\{[\w\W]*/gm), Ct = N(/^data-[\-\w.\u00B7-\uFFFF]+$/), xt = N(/^aria-[\-\w]+$/), Be = N(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), Mt = N(/^(?:\w+script|data):/i), kt = N(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), We = N(/^html$/i), It = N(/^[a-z][.\w]*(-[.\w]+)+$/i);
    var Ge = Object.freeze({ __proto__: null, ARIA_ATTR: xt, ATTR_WHITESPACE: kt, CUSTOM_ELEMENT: It, DATA_ATTR: Ct, DOCTYPE_NAME: We, ERB_EXPR: vt, IS_ALLOWED_URI: Be, IS_SCRIPT_OR_DATA: Mt, MUSTACHE_EXPR: Dt, TMPLIT_EXPR: Lt });
    const Ut = 1, zt = 3, Pt = 7, Ht = 8, Ft = 9, Bt = function() {
      return typeof window > "u" ? null : window;
    };
    var Wt = function s() {
      let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Bt();
      const o = (e) => s(e);
      if (o.version = "3.2.4", o.removed = [], !l || !l.document || l.document.nodeType !== Ft || !l.Element) return o.isSupported = !1, o;
      let { document: u } = l;
      const S = u, Y = S.currentScript, { DocumentFragment: Ye, HTMLTemplateElement: Gt, Node: he, Element: je, NodeFilter: j, NamedNodeMap: Yt = l.NamedNodeMap || l.MozNamedAttrMap, HTMLFormElement: jt, DOMParser: Xt, trustedTypes: ee } = l, X = je.prototype, qt = G(X, "cloneNode"), $t = G(X, "remove"), Kt = G(X, "nextSibling"), Vt = G(X, "childNodes"), te = G(X, "parentNode");
      if (typeof Gt == "function") {
        const e = u.createElement("template");
        e.content && e.content.ownerDocument && (u = e.content.ownerDocument);
      }
      let E, q = "";
      const { implementation: Te, createNodeIterator: Zt, createDocumentFragment: Jt, getElementsByTagName: Qt } = u, { importNode: en } = S;
      let A = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
      o.isSupported = typeof C == "function" && typeof te == "function" && Te && Te.createHTMLDocument !== void 0;
      const { MUSTACHE_EXPR: ye, ERB_EXPR: Ee, TMPLIT_EXPR: Ae, DATA_ATTR: tn, ARIA_ATTR: nn, IS_SCRIPT_OR_DATA: on, ATTR_WHITESPACE: Xe, CUSTOM_ELEMENT: rn } = Ge;
      let { IS_ALLOWED_URI: qe } = Ge, p = null;
      const $e = r({}, [...ze, ...fe, ...pe, ...de, ...Pe]);
      let g = null;
      const Ke = r({}, [...He, ...ge, ...Fe, ...Q]);
      let m = Object.seal(Me(null, { tagNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, attributeNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, allowCustomizedBuiltInElements: { writable: !0, configurable: !1, enumerable: !0, value: !1 } })), $ = null, _e = null, Ve = !0, Se = !0, Ze = !1, Je = !0, k = !1, Ne = !0, M = !1, be = !1, Re = !1, I = !1, ne = !1, oe = !1, Qe = !0, et = !1, we = !0, K = !1, U = {}, z = null;
      const tt = r({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
      let nt = null;
      const ot = r({}, ["audio", "video", "img", "source", "image", "track"]);
      let Oe = null;
      const rt = r({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), re = "http://www.w3.org/1998/Math/MathML", ae = "http://www.w3.org/2000/svg", D = "http://www.w3.org/1999/xhtml";
      let P = D, De = !1, ve = null;
      const an = r({}, [re, ae, D], me);
      let ie = r({}, ["mi", "mo", "mn", "ms", "mtext"]), le = r({}, ["annotation-xml"]);
      const ln = r({}, ["title", "style", "font", "a", "script"]);
      let V = null;
      const sn = ["application/xhtml+xml", "text/html"];
      let d = null, H = null;
      const cn = u.createElement("form"), at = function(e) {
        return e instanceof RegExp || e instanceof Function;
      }, Le = function() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!H || H !== e) {
          if (e && typeof e == "object" || (e = {}), e = x(e), V = sn.indexOf(e.PARSER_MEDIA_TYPE) === -1 ? "text/html" : e.PARSER_MEDIA_TYPE, d = V === "application/xhtml+xml" ? me : J, p = R(e, "ALLOWED_TAGS") ? r({}, e.ALLOWED_TAGS, d) : $e, g = R(e, "ALLOWED_ATTR") ? r({}, e.ALLOWED_ATTR, d) : Ke, ve = R(e, "ALLOWED_NAMESPACES") ? r({}, e.ALLOWED_NAMESPACES, me) : an, Oe = R(e, "ADD_URI_SAFE_ATTR") ? r(x(rt), e.ADD_URI_SAFE_ATTR, d) : rt, nt = R(e, "ADD_DATA_URI_TAGS") ? r(x(ot), e.ADD_DATA_URI_TAGS, d) : ot, z = R(e, "FORBID_CONTENTS") ? r({}, e.FORBID_CONTENTS, d) : tt, $ = R(e, "FORBID_TAGS") ? r({}, e.FORBID_TAGS, d) : {}, _e = R(e, "FORBID_ATTR") ? r({}, e.FORBID_ATTR, d) : {}, U = !!R(e, "USE_PROFILES") && e.USE_PROFILES, Ve = e.ALLOW_ARIA_ATTR !== !1, Se = e.ALLOW_DATA_ATTR !== !1, Ze = e.ALLOW_UNKNOWN_PROTOCOLS || !1, Je = e.ALLOW_SELF_CLOSE_IN_ATTR !== !1, k = e.SAFE_FOR_TEMPLATES || !1, Ne = e.SAFE_FOR_XML !== !1, M = e.WHOLE_DOCUMENT || !1, I = e.RETURN_DOM || !1, ne = e.RETURN_DOM_FRAGMENT || !1, oe = e.RETURN_TRUSTED_TYPE || !1, Re = e.FORCE_BODY || !1, Qe = e.SANITIZE_DOM !== !1, et = e.SANITIZE_NAMED_PROPS || !1, we = e.KEEP_CONTENT !== !1, K = e.IN_PLACE || !1, qe = e.ALLOWED_URI_REGEXP || Be, P = e.NAMESPACE || D, ie = e.MATHML_TEXT_INTEGRATION_POINTS || ie, le = e.HTML_INTEGRATION_POINTS || le, m = e.CUSTOM_ELEMENT_HANDLING || {}, e.CUSTOM_ELEMENT_HANDLING && at(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (m.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e.CUSTOM_ELEMENT_HANDLING && at(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (m.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e.CUSTOM_ELEMENT_HANDLING && typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (m.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), k && (Se = !1), ne && (I = !0), U && (p = r({}, Pe), g = [], U.html === !0 && (r(p, ze), r(g, He)), U.svg === !0 && (r(p, fe), r(g, ge), r(g, Q)), U.svgFilters === !0 && (r(p, pe), r(g, ge), r(g, Q)), U.mathMl === !0 && (r(p, de), r(g, Fe), r(g, Q))), e.ADD_TAGS && (p === $e && (p = x(p)), r(p, e.ADD_TAGS, d)), e.ADD_ATTR && (g === Ke && (g = x(g)), r(g, e.ADD_ATTR, d)), e.ADD_URI_SAFE_ATTR && r(Oe, e.ADD_URI_SAFE_ATTR, d), e.FORBID_CONTENTS && (z === tt && (z = x(z)), r(z, e.FORBID_CONTENTS, d)), we && (p["#text"] = !0), M && r(p, ["html", "head", "body"]), p.table && (r(p, ["tbody"]), delete $.tbody), e.TRUSTED_TYPES_POLICY) {
            if (typeof e.TRUSTED_TYPES_POLICY.createHTML != "function") throw W('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
            if (typeof e.TRUSTED_TYPES_POLICY.createScriptURL != "function") throw W('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
            E = e.TRUSTED_TYPES_POLICY, q = E.createHTML("");
          } else E === void 0 && (E = function(n, t) {
            if (typeof n != "object" || typeof n.createPolicy != "function") return null;
            let i = null;
            const c = "data-tt-policy-suffix";
            t && t.hasAttribute(c) && (i = t.getAttribute(c));
            const a = "dompurify" + (i ? "#" + i : "");
            try {
              return n.createPolicy(a, { createHTML: (f) => f, createScriptURL: (f) => f });
            } catch {
              return console.warn("TrustedTypes policy " + a + " could not be created."), null;
            }
          }(ee, Y)), E !== null && typeof q == "string" && (q = E.createHTML(""));
          h && h(e), H = e;
        }
      }, it = r({}, [...fe, ...pe, ...wt]), lt = r({}, [...de, ...Ot]), w = function(e) {
        F(o.removed, { element: e });
        try {
          te(e).removeChild(e);
        } catch {
          $t(e);
        }
      }, se = function(e, n) {
        try {
          F(o.removed, { attribute: n.getAttributeNode(e), from: n });
        } catch {
          F(o.removed, { attribute: null, from: n });
        }
        if (n.removeAttribute(e), e === "is") if (I || ne) try {
          w(n);
        } catch {
        }
        else try {
          n.setAttribute(e, "");
        } catch {
        }
      }, st = function(e) {
        let n = null, t = null;
        if (Re) e = "<remove></remove>" + e;
        else {
          const a = Ie(e, /^[\r\n\t ]+/);
          t = a && a[0];
        }
        V === "application/xhtml+xml" && P === D && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
        const i = E ? E.createHTML(e) : e;
        if (P === D) try {
          n = new Xt().parseFromString(i, V);
        } catch {
        }
        if (!n || !n.documentElement) {
          n = Te.createDocument(P, "template", null);
          try {
            n.documentElement.innerHTML = De ? q : i;
          } catch {
          }
        }
        const c = n.body || n.documentElement;
        return e && t && c.insertBefore(u.createTextNode(t), c.childNodes[0] || null), P === D ? Qt.call(n, M ? "html" : "body")[0] : M ? n.documentElement : c;
      }, ct = function(e) {
        return Zt.call(e.ownerDocument || e, e, j.SHOW_ELEMENT | j.SHOW_COMMENT | j.SHOW_TEXT | j.SHOW_PROCESSING_INSTRUCTION | j.SHOW_CDATA_SECTION, null);
      }, Ce = function(e) {
        return e instanceof jt && (typeof e.nodeName != "string" || typeof e.textContent != "string" || typeof e.removeChild != "function" || !(e.attributes instanceof Yt) || typeof e.removeAttribute != "function" || typeof e.setAttribute != "function" || typeof e.namespaceURI != "string" || typeof e.insertBefore != "function" || typeof e.hasChildNodes != "function");
      }, ut = function(e) {
        return typeof he == "function" && e instanceof he;
      };
      function v(e, n, t) {
        Z(e, (i) => {
          i.call(o, n, t, H);
        });
      }
      const mt = function(e) {
        let n = null;
        if (v(A.beforeSanitizeElements, e, null), Ce(e)) return w(e), !0;
        const t = d(e.nodeName);
        if (v(A.uponSanitizeElement, e, { tagName: t, allowedTags: p }), e.hasChildNodes() && !ut(e.firstElementChild) && T(/<[/\w]/g, e.innerHTML) && T(/<[/\w]/g, e.textContent) || e.nodeType === Pt || Ne && e.nodeType === Ht && T(/<[/\w]/g, e.data)) return w(e), !0;
        if (!p[t] || $[t]) {
          if (!$[t] && pt(t) && (m.tagNameCheck instanceof RegExp && T(m.tagNameCheck, t) || m.tagNameCheck instanceof Function && m.tagNameCheck(t)))
            return !1;
          if (we && !z[t]) {
            const i = te(e) || e.parentNode, c = Vt(e) || e.childNodes;
            if (c && i)
              for (let a = c.length - 1; a >= 0; --a) {
                const f = qt(c[a], !0);
                f.__removalCount = (e.__removalCount || 0) + 1, i.insertBefore(f, Kt(e));
              }
          }
          return w(e), !0;
        }
        return e instanceof je && !function(i) {
          let c = te(i);
          c && c.tagName || (c = { namespaceURI: P, tagName: "template" });
          const a = J(i.tagName), f = J(c.tagName);
          return !!ve[i.namespaceURI] && (i.namespaceURI === ae ? c.namespaceURI === D ? a === "svg" : c.namespaceURI === re ? a === "svg" && (f === "annotation-xml" || ie[f]) : !!it[a] : i.namespaceURI === re ? c.namespaceURI === D ? a === "math" : c.namespaceURI === ae ? a === "math" && le[f] : !!lt[a] : i.namespaceURI === D ? !(c.namespaceURI === ae && !le[f]) && !(c.namespaceURI === re && !ie[f]) && !lt[a] && (ln[a] || !it[a]) : !(V !== "application/xhtml+xml" || !ve[i.namespaceURI]));
        }(e) ? (w(e), !0) : t !== "noscript" && t !== "noembed" && t !== "noframes" || !T(/<\/no(script|embed|frames)/i, e.innerHTML) ? (k && e.nodeType === zt && (n = e.textContent, Z([ye, Ee, Ae], (i) => {
          n = B(n, i, " ");
        }), e.textContent !== n && (F(o.removed, { element: e.cloneNode() }), e.textContent = n)), v(A.afterSanitizeElements, e, null), !1) : (w(e), !0);
      }, ft = function(e, n, t) {
        if (Qe && (n === "id" || n === "name") && (t in u || t in cn)) return !1;
        if (!(Se && !_e[n] && T(tn, n))) {
          if (!(Ve && T(nn, n))) {
            if (!g[n] || _e[n]) {
              if (!(pt(e) && (m.tagNameCheck instanceof RegExp && T(m.tagNameCheck, e) || m.tagNameCheck instanceof Function && m.tagNameCheck(e)) && (m.attributeNameCheck instanceof RegExp && T(m.attributeNameCheck, n) || m.attributeNameCheck instanceof Function && m.attributeNameCheck(n)) || n === "is" && m.allowCustomizedBuiltInElements && (m.tagNameCheck instanceof RegExp && T(m.tagNameCheck, t) || m.tagNameCheck instanceof Function && m.tagNameCheck(t)))) return !1;
            } else if (!Oe[n]) {
              if (!T(qe, B(t, Xe, ""))) {
                if ((n !== "src" && n !== "xlink:href" && n !== "href" || e === "script" || Nt(t, "data:") !== 0 || !nt[e]) && !(Ze && !T(on, B(t, Xe, "")))) {
                  if (t) return !1;
                }
              }
            }
          }
        }
        return !0;
      }, pt = function(e) {
        return e !== "annotation-xml" && Ie(e, rn);
      }, dt = function(e) {
        v(A.beforeSanitizeAttributes, e, null);
        const { attributes: n } = e;
        if (!n || Ce(e)) return;
        const t = { attrName: "", attrValue: "", keepAttr: !0, allowedAttributes: g, forceKeepAttr: void 0 };
        let i = n.length;
        for (; i--; ) {
          const c = n[i], { name: a, namespaceURI: f, value: L } = c, O = d(a);
          let _ = a === "value" ? L : bt(L);
          if (t.attrName = O, t.attrValue = _, t.keepAttr = !0, t.forceKeepAttr = void 0, v(A.uponSanitizeAttribute, e, t), _ = t.attrValue, !et || O !== "id" && O !== "name" || (se(a, e), _ = "user-content-" + _), Ne && T(/((--!?|])>)|<\/(style|title)/i, _)) {
            se(a, e);
            continue;
          }
          if (t.forceKeepAttr || (se(a, e), !t.keepAttr)) continue;
          if (!Je && T(/\/>/i, _)) {
            se(a, e);
            continue;
          }
          k && Z([ye, Ee, Ae], (ht) => {
            _ = B(_, ht, " ");
          });
          const gt = d(e.nodeName);
          if (ft(gt, O, _)) {
            if (E && typeof ee == "object" && typeof ee.getAttributeType == "function" && !f) switch (ee.getAttributeType(gt, O)) {
              case "TrustedHTML":
                _ = E.createHTML(_);
                break;
              case "TrustedScriptURL":
                _ = E.createScriptURL(_);
            }
            try {
              f ? e.setAttributeNS(f, a, _) : e.setAttribute(a, _), Ce(e) ? w(e) : ke(o.removed);
            } catch {
            }
          }
        }
        v(A.afterSanitizeAttributes, e, null);
      }, un = function e(n) {
        let t = null;
        const i = ct(n);
        for (v(A.beforeSanitizeShadowDOM, n, null); t = i.nextNode(); ) v(A.uponSanitizeShadowNode, t, null), mt(t), dt(t), t.content instanceof Ye && e(t.content);
        v(A.afterSanitizeShadowDOM, n, null);
      };
      return o.sanitize = function(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = null, i = null, c = null, a = null;
        if (De = !e, De && (e = "<!-->"), typeof e != "string" && !ut(e)) {
          if (typeof e.toString != "function") throw W("toString is not a function");
          if (typeof (e = e.toString()) != "string") throw W("dirty is not a string, aborting");
        }
        if (!o.isSupported) return e;
        if (be || Le(n), o.removed = [], typeof e == "string" && (K = !1), K) {
          if (e.nodeName) {
            const O = d(e.nodeName);
            if (!p[O] || $[O]) throw W("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (e instanceof he) t = st("<!---->"), i = t.ownerDocument.importNode(e, !0), i.nodeType === Ut && i.nodeName === "BODY" || i.nodeName === "HTML" ? t = i : t.appendChild(i);
        else {
          if (!I && !k && !M && e.indexOf("<") === -1) return E && oe ? E.createHTML(e) : e;
          if (t = st(e), !t) return I ? null : oe ? q : "";
        }
        t && Re && w(t.firstChild);
        const f = ct(K ? e : t);
        for (; c = f.nextNode(); ) mt(c), dt(c), c.content instanceof Ye && un(c.content);
        if (K) return e;
        if (I) {
          if (ne) for (a = Jt.call(t.ownerDocument); t.firstChild; ) a.appendChild(t.firstChild);
          else a = t;
          return (g.shadowroot || g.shadowrootmode) && (a = en.call(S, a, !0)), a;
        }
        let L = M ? t.outerHTML : t.innerHTML;
        return M && p["!doctype"] && t.ownerDocument && t.ownerDocument.doctype && t.ownerDocument.doctype.name && T(We, t.ownerDocument.doctype.name) && (L = "<!DOCTYPE " + t.ownerDocument.doctype.name + `>
` + L), k && Z([ye, Ee, Ae], (O) => {
          L = B(L, O, " ");
        }), E && oe ? E.createHTML(L) : L;
      }, o.setConfig = function() {
        Le(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}), be = !0;
      }, o.clearConfig = function() {
        H = null, be = !1;
      }, o.isValidAttribute = function(e, n, t) {
        H || Le({});
        const i = d(e), c = d(n);
        return ft(i, c, t);
      }, o.addHook = function(e, n) {
        typeof n == "function" && F(A[e], n);
      }, o.removeHook = function(e, n) {
        if (n !== void 0) {
          const t = _t(A[e], n);
          return t === -1 ? void 0 : St(A[e], t, 1)[0];
        }
        return ke(A[e]);
      }, o.removeHooks = function(e) {
        A[e] = [];
      }, o.removeAllHooks = function() {
        A = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
      }, o;
    }();
    return Wt;
  });
});
export default fn();
